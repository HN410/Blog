{"pages":[{"title":"Not Found","text":"お探しの記事は見つかりませんでした。","link":"/404.html"}],"posts":[{"title":"フォントを生成するGANを作った話(前編)","text":"2021 ISer Advent Calendar 19日目の記事です． 記事が長くなりそうでかつ19日が開いていたので，内容を2つに分けてお送りします． 突然ですが，皆さんはこのような経験はありませんか？ おお～．いかしたフォントだな～… なんのフォント使ってるんだろ？ ……… このように，見つけたフォントがなんのフォントか知りたいのにどう検索すればいいのかわからない…． じゃあ，自分で作ればいいじゃない! ということで作られたのがこちらになります． 概要 実装 データ収集，チェック 次回予告と近況 使用させていただいた素材 概要 目的のフォントで描画した画像の組を複数と，変換したい文字を入力することで，その文字を目的のフォントで描画した画像を生成するモデルを訓練するGANを作成しました． 大体こんな感じ 実装 Generator部分について，実際の実装をもう少し細かく見ると以下のようになっており，文字のエンコードをする部分，フォントのエンコードをする部分，それらをもとに画像を生成する部分の3つに分けられます． 大体こんな感じ 文字，フォントのエンコードをする部分ではEfficientNetという画像認識モデル[1]を，生成する部分ではStyleGANという画像生成モデルを用いており，この全体の構成はpixel2style2pixelを基にしています． これらのモデルについての説明は様々なサイトで記事にされているのでそちらに譲ります． また，入力した画像がGeneratorが生成したものか，既存のフォントでレンダリングしたものかを判別するDiscriminatorも，EfficientNetを基にしております． データ収集，チェック ネットワークを作ったところで早速訓練と行きたいところですが，まずはデータの収集とそのチェックがあります．画像に比べれば一枚一枚チェックしなくて言い分楽ですが，それでも検査しなければいけないことは沢山あります． 例えば， 英数字，かな，漢字のうちどれに対応しているか(英数字だけ，かなだけ，ごく一部の文字だけに対応など，いろいろなパターンがある)[2] アルファベットの大文字小文字両方に対応しているか (英数字のみに対応するフォントで，小文字も大文字として表示しているフォントがたまにある) (g, バックスラッシュなど，異なる字体が存在する文字の表記がデータセット内で統一されているか) 等があります． この作業を効率化させるため，ipywidgetsというライブラリを使用しました． 画像のように，JupyterNotebook上でGUIを構築し，操作をすることができるので，ちょっとした作業におすすめです． 実際に作成したGUI 次回予告と近況 次回は訓練についてと(途中)結果について書きます． この記事を公開する数日前にバグが発覚したのと，改善案を思いついたということもあり，現在急いで学習のやり直しをしております． 果たして後編までに間に合うんでしょうか(). 使用させていただいた素材 thinking-face … https://icon-icons.com/icon/thinking-face/110034 GUIのフォント … しろくまフォント 厳密にはこれにmap2styleというpSpのモデルの一部を組み合わせたネットワーク ↩︎ このチェックは自動化できそうに思うかもしれませんが，対応外の文字もレンダリングできてしまう上に，その結果もまちまち（何も表示されなかったり豆腐になったり）なので，実際に目視したほうが早いと思います． ↩︎","link":"/2021/12/19/20211219/"},{"title":"BrainF*ckで15パズル","text":"折角ブログをつくったので，部誌で書いた記事を少し改変してここで再掲したいと思います． プログラミングを学び始めたときに初心者用の言語としてBrainF*ckが紹介されていたので，それで作った15パズルを紹介します．この言語についてはネットに沢山解説記事が上がっているのでそちらを参照ください． プログラム 概要 メモリの割り振り 初期設定 入力キーの判定、移動処理 描画 まとめ プログラム 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 ※po=xはポインタの位置がｘ番メモリにあるの意味。最初のメモリは１番メモリとする。 指定されたメモリにパズルの番号＋６６を入力。改行の箇所には１０、空白は０、その他は１+&gt;+&gt;+&gt;+&gt;++++[&gt;++++&lt;-]+&gt; po=6[&gt;++++&gt;++++&gt;++++&gt;++++&gt;+&gt;&gt;++++&gt;++++&gt;++++&gt;++++&gt;+&gt;&gt;++++&gt;++++&gt;++++&gt;++++&gt;+&gt;&gt;++++&gt;++++&gt;++++&gt;&gt;+ po=29&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]+ po=6&gt;+++&gt;++++&gt;+++++&gt;++++++ &gt;------&gt;+&gt;+++++++&gt;++++++++&gt;+++++++++&gt;++++++++++ &gt;------&gt;+&gt;+++++++++++&gt;++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;------&gt;+&gt;+++++++++++++++&gt;++++++++++++++++&gt;+++++++++++++++++ &gt;&gt;------&gt;+&gt;+&gt;+&gt;+&gt;+&gt; ここまで初期設定 po=35 以下ループ ※一旦１を代入しておいてループの部分が飛ばされてしまうのを防ぐ+[- ここから描画処理 マスの先頭へ&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; po=7 全体にー２して出力させることで、空白のメモリをー２＝１２６にし、チルダを出力させる。 --.++&gt;--.++&gt;--.++&gt;--.++&gt;.&gt;&gt; --.++&gt;--.++&gt;--.++&gt;--.++&gt;.&gt;&gt;--.++&gt;--.++&gt;--.++&gt;--.++&gt;.&gt;&gt;--.++&gt;--.++&gt;--.++&gt;--.++&gt;.&gt;&gt; po=31&gt;&gt;&gt;&gt; po=35 以上。入力へ, 読み込んだ値を３６、３８、４０、４２にコピー [-&gt;+&gt;&gt;+&gt;&gt;+&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;] po=35 入力がAかどうかの判定 &gt;&gt;++++++++++++[-&lt;--------&gt;]&lt;- ３６の値から９７を引く、po=36 &gt;+&lt;[&gt;-&lt;[-]]&gt;[ Aならここを実行、あとは飛ばす po=37 ３８、４０、４２に十分大きな値を入れて負になるのを防ぐ。 &gt;&gt;+++++[&lt;+++++&gt;-] &gt;&gt;+++++[&lt;+++++&gt;-] &gt;&gt;+++++[&lt;+++++&gt;-] po=43 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; po=33 [&lt;] パズルの空白の位置まで移動 &lt;-[ 空白の左隣が１じゃないならここを実行 [&gt;+&lt;-]&gt;+&lt;] 左隣の値を空白に移動 +&gt;[&lt;-]&gt;&gt;&gt;[&gt;] もし空白だったところの左隣が１だったら、現在０になっているので、そのときのみ１を足して元に戻す po=35 &gt;&gt;-] ３７番を０にする 以上、Aの判定 Dの判定 &gt;&gt;++++++++++[-&lt;----------&gt;]&lt; po=38 &gt;+&lt;[&gt;-&lt;[-]]&gt;[ po=39 &gt;&gt;+++++[&lt;+++++&gt;-] po=41 &gt;&gt;+++++[&lt;+++++&gt;-] po=43 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&lt;] &gt;----------[ [&lt;+&gt;-]&lt;++++++++++&gt;] ++++++++++&lt;[&gt;----------]&gt;&gt;[&gt;] &gt;&gt;&gt;&gt;-] if po 38 = d now po=39 Sの判定 &gt;&gt;+++++++++++[-&lt;----------&gt;]&lt;----- po=40 minus115 &gt;+&lt;[&gt;-&lt;[-]]&gt;[ po=41 &gt;+++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&lt;] &gt;&gt;&gt;&gt;&gt;&gt;-[ [&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;] +&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;&gt;-]&gt;[&gt;] &gt;&gt;&gt;&gt;&gt;&gt;-] if po 40 = s now po=41 Wの判定 &gt;&gt;+++++++++++[-&lt;----------&gt;]&lt;--------- po=42 minus119 &gt;+&lt;[&gt;-&lt;[-]]&gt;[ po=43 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&lt;] &lt;&lt;&lt;&lt;&lt;&lt;-[ [&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;] +&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;[&gt;] &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-] if po 42 = w now po=43&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; po=35 出入力へループ+] 概要 A～Nはそれぞれ１～１５に対応し、?が空白となっております。操作はBrainFckの入力パネルにw(半角)を入力することで空白に対応する部分が上に、a,s,dも同様にそれぞれ左、下、右に動きます。 BrainFck製である以上、以下の欠陥があります。 シャッフル機能がないです。なんか適当に文字入力してもらうのも考えましたが、面d(ry インタプリタによっては、入力してもまた入力ウィンドウがでる無限ループに入ります。 メモリの割り振り 使用したメモリの数は４３です。下に主な用途を書きますが、この言語の特性上このほかにメモリをいろいろ使いまわします．例えば３５、３６はパズルの描画のために「６３」を一時的に作るために使われます。 メモリの位置 主な用途 備考 １～３４ パズルのマスに対応 なぜ３４マスもあるかは後述 ３５ キーの入力値を一時格納 すぐに３６,３８,４０,４２にコピー ３６,３７ Aが入力された時の判定 以下、４２,４３までそれぞれD,S,Wに対応 初期設定 まず、マスの状況を保存する部分をはじめに１５パズルの揃った状況に設定します。ここで、本来の１６マスよりも大幅に多い３４個のメモリを使う理由ですが、下のように４×４のマスを６×６に拡張したためです（いわゆる番兵の設置）。 このようにメモリを拡張することで、実際に用いる真ん中の１６個のメモリのある場所からの上下左右が常に±１、６になります。このとき、パズルに対応する１６個のメモリのうち、数字に対応する部分はその値＋１を、空白の部分は０を格納します。周囲のメモリは１を入力しておきます。空白に対応する部分を０にすることで、‘’]''の命令で０か正かしか判定できないこの言語で後で参照しやすくします。 入力キーの判定、移動処理 この後、入力待ちの状態にし、３５番メモリにそれを8ビットの整数で代入させ、それを４箇所にコピーします（コピー元は消えちゃいます）。入力が予想される値はa(９７),d(１００),s(１１５),w(１１９) {括弧内は文字コードの１０進数値}で、まず文字コードの値が若い順に処理します。コピーした値のうち１つから９７を引き、０になるかを判定します。（この判定の書き方はこちらをパクらせていただきました。）もし０ならさっきコピーした残りの値に十分大きな値を足しておいて（別の値の判定で９７より大きい値を引いて負にさせないため）、パズルの移動にかかります。といっても１～３４のメモリの中で０になっている値とその左隣の値を交換するだけなので単純です。ただし、空白の左隣がパズルの４×４マスの外（つまり値が１）なら、その移動は実行しません。 この処理をd,s,wでも行います。 描画 移動処理が終われば描画するだけですが、これはマスの状態が記録されてるメモリに６３を足して出力する(Aの文字コードの値は６５)だけなので大したことないです。３５、３６番メモリ（このとき、値は常に０です）に６３をあらかじめ作っておき、一気に該当のメモリに足したあと順に出力します。このとき、パズルの４*４のマスの右の外にある列に対応するメモリの値は１０にして改行を出力させます。 あとはメモリの値を元に戻してループさせるだけです。 まとめ 今思うとよくこんな面倒なものを作ったなあと思いました。この時期にNP性の証明とか書かせてたらチューリングマシンの動作をきちんと書いてたかもしれません。","link":"/2022/01/09/BrainF15/"},{"title":"フォントを生成するGANを作った話(後編)","text":"2021 ISer Advent Calendar 23日目の記事です． まだ前回の記事を読んでいない，あるいはもう忘れたという方は前回の記事を読まれることをお勧めします． 訓練１ 訓練2 (途中)結果 感想 備忘録 余談 使用させていただいたフォント 訓練１ さて，ようやく訓練フェーズに入ったわけですが，前述のネットワークをそのまま訓練しようとすると，非常に時間がかかるので，段階的に訓練していきます．まずはモデルの低層部分である，文字の画像を次元削減し，再び文字の画像を生成する部分（いわゆるオートエンコーダ）を学習します．下図のようにGeneratorの低層部分の出力から画像を生成し，元の文字の画像と一致するように訓練させることを順に行います． 該当するモデルの図． ここで難しいのが，どの程度までこのモデルを訓練させるかです．変換できる文字の種類を今回学習する文字[1]に限ってしまえば，母集団＝標本となるため，過適合がなく，訓練すればするほど精度が上昇するのですが，それ以外の文字もある程度変換できるようにしたい場合は早期に切り上げる必要があります． 今回は，頻出する構造がはっきりと再現できる程度に訓練をしました．特に再現に時間がかかった構造としては，かなの半濁点，諫などの内部の点，馬へんなどのれんがの部分があります． 訓練途中の結果．それぞれ左側は入力，右側が出力された画像となっている． 誰ですかこんな漢字を考えたのは． また，この訓練の損失関数は初めはL1損失を用いました．フォント画像を出力するので，ぼやけた画像よりも二値化されたような画像のほうが望ましいためこの選択をしたのですが，意外と学習が遅く，数千エポック回しても下図のような細かい構造が再現できませんでした．これをもってL2損失に切り替えたところ，100エポックほどで以下のような画像を出力しました．この時は出力にシグモイド関数を挟んでいたため，L2損失を使うと勾配消失が起きるのではないかと思っていましたが…難しいものですね． 左から，入力，L1損失で学習した際の出力, その後L2損失で学習した際の出力．口の横棒や，髟を見ると違いが分かりやすい． 訓練2 ようやくGANとしての訓練を始められますが，その前に．Generatorが生成した画像の分類を行うDiscriminatorを説明します． まず，Generatorが生成した画像か変換先のフォントの画像かを判別する通常のDiscriminatorを用意します．これには前述の画像のほかに，Genarotrに入力した画像と同じ変換先のフォントの組も同時に入れます．これにより，DiscriminatorはGeneratorが作った画像かどうかというよりは，入力された画像の文字が同じフォントに属するかという判定を行います． これに加えて，入力された画像が何の文字かを判定するCharaDiscriminatorも用意しました．これは文字の代わりにそれに対応する特徴量ベクトルを出力します．訓練はこの特徴量がGenerator内のCharaEncoderの出力と一致するように行います． 以上の分類器とともに以下の図のように2つの損失を算出し，最小化させていくことでGeneratorを訓練していきます．同時にDiscriminatorにも損失関数を用意し，訓練させています． Generatorの訓練の様子．Generatorだけでなく2つのDiscriminatorも用意して損失を算出する． Generatorが出力した画像(とそのほか必要な入力)をそれぞれ分類器に入れ，Generator, 分類器ごとにそれぞれの損失関数を最小化しさせました． (途中)結果 今のところの結果をあげておきます． まずはうまくいっている(ように見える)例から．以下で挙げる画像は，左から，変換したい字(入力)，変換先の教師画像，Generatorの出力結果，変換したいフォントで書いた字の画像2組(入力)となっております． validデータの変換の例． この例については，教師画像とはあまり一致していないように見えますが，例えば横棒が終端が太く，それ以外は細いといった特徴は表現できているように見えます． もちろんこんなにうまくいくものばかりではありません．下のようになんか背景が真っ白になっている時があったり， validデータの変換例2． ゴシック体と大きく異なるフォントは全然学習できてなかったりとなかなか課題は多そうです． trainデータの変換例2． ほかにも， 明らかに他の画像の特徴で表現されている →他の画像の学習結果が大きくでてしまった? 周りに変なごみが出る(うまくいった例の画像などにも出てる) ^ , .などの小さい字が異様に膨らむ などの問題があります． また，フォントの大きさの変化，回転などといった特徴は表現できないことも分かっております，これはおそらくフォントのエンコードをする部分で主にConvolutionレイヤを使っているモデルを使用していることが原因だと思いますが，特に支障をきたさなそうなのでそのまま訓練を続けようと思っております[2]， 感想 とにかくGenerator, Discriminatorの訓練バランス調整が難しく，崩れた途端意味のない画像しか生成しなくなるので，苦戦させられました．その調整ができても，訓練に時間がかかるという問題があり，それを改善しようとしてバランスが崩れる… というようなイタチゴッコが続いており，つらいです． ただ，今のところはうまくいってそうでその点は少し気が楽なので，もう少し続けてみようと思います． 備忘録 初めてのGANの訓練でつまずいたところ，気づいたところを書いておきます． Dのちょうどいい正解率がよくわからない 50%がちょうどいい正解率らしいけど，Dが全然学習してないときとの区別ができない とりあえず65~55%あたりにしてみる G, Dのバランス調整はdropout率を動かすのが早い Dの正解率等に応じて動的に調整できればなお楽 人の実装はしっかりコードを読んで意味を確認してから使うこと 自分の直感とは違う書き方がたまにされている これで損失関数の符号が逆になったまま訓練してました() メモリが足りなくなったらdel; torch.cuda.empty_cache(); gc.collect()をする バッチサイズを大きくして訓練できる でもこれをすると逆効果になることもある 地味に時間も食うので毎iterationやるときなどは必要がなければ使わないほうがいいかも 勾配を伝播させる必要のないテンソルはdetach()で計算グラフから切り離す しなくてもバグらないけどメモリをかなり無駄遣いする GANで必須のテクニックだと思うけど意外と解説が少ない気がする line_profilerやtorchinfo.summaryで時間，メモリの無駄遣いをしているところを探す 損失関数をAdamにこだわらない RMSPropやAdamWが意外といけるときもある 余談 最後に，訓練中の出力画像を表示してくれたTensorboard君の渾身の煽りを御覧ください． (こ)ここガバ 使用させていただいたフォント しろくまフォント FZイモケンピ 棘薔薇フォント Nuきなこもち ASCII文字，かな，JIS第一，第二水準の漢字 ↩︎ むしろそのような変化を吸収出来たほうが都合よい気がします(写真で撮影したものからフォントを生成したいときなど) ↩︎","link":"/2021/12/23/20211223/"},{"title":"CPU実験の変更点(暫定)","text":"あけましておめでとうございます． この記事にアクセスしてくださった方はご存じかもしれませんが，東京大学理学部情報科学科ではCPU実験という名物授業があります．どんな授業かというと，班員で役割分担をし，mincamlという言語で書かれたプログラムを動かすデバイスをFPGA[1]で1から作るという授業です．詳しい概要については先輩方が書いたブログなどにも書かれているのでそちらをご覧ください． しかしながら，担当教員の変更と去年に引き続いて例のウイルスの影響を受け，今年から大幅に内容が変更されました． これが永続的なものかはわかりませんが，記録として残しておきたいと思います．もし，後輩の方が私より前の世代の方のブログを見る際に参考にしていただければと思います． 全般 授業が対面→オンラインと対面のハイブリッド型へ (地下が利用不可能に) ハードウェア 配布されるFPGAボードの性能が低下 DDR2メモリの使用が性能的にほぼ必須に 単位要件 コンパイラ実験の課題の割り振りの変更 FPU係がFPU・メモリ係に変更 キャッシュの開発が必須に シミュレータ係に実行時間予測のタスクが追加 発展課題として512×512の画像サイズのレイトレが追加 全般 授業が対面→オンラインと対面のハイブリッド型へ コンパイラ実験は完全オンラインですが，プロセッサ実験は生徒が対面，オンラインを自由に選べます．しかし，対面授業は他の班の同級生と情報交換ができる貴重な場だった[2]ので多くの人が対面で受けていました． (地下が利用不可能に) 去年に引き続き，地下が利用不可能となった状態で開発を行いました． おそらく2022年は使えるはず…? ハードウェア 配布されるFPGAボードの性能が低下 これは決して予算が削られたわけではなく(たぶん)，今までは班に一つ配布されていたものが一人に一つに増やされたためです[3]． これにより以下の変更が発生します． DDR2メモリの使用が性能的にほぼ必須に 以上より，FPGAのBRAMの容量が減ったため，特に工夫をしなかった場合，容量不足となります．そのため，BRAMをキャッシュとして用い，DDR2メモリをメモリとして扱うことを強いられます．後述しますが，キャッシュの開発も単位要件として追加されたので無理やりBRAMしか使わないようにすることは認められません． 単位要件 コンパイラ実験の課題の割り振りの変更 一部の個人課題がグループ課題になる，必須提出数の増加などがありました．全体的には負担が増した気がします． FPU係がFPU・メモリ係に変更 メモリの変化により，FPU係にキャッシュシステムを含むメモリ開発の役割が増えました． キャッシュの開発が必須に 前述したようにDDR2メモリの使用が必須になったため，これだけを使うと速度が著しく低下します．そのため，BRAMをキャッシュとして用いることが必須になりました． シミュレータ係に実行時間予測のタスクが追加 今までは動作のシミュレーションだけを行うソフトを作れば単位を確定できましたが，それに加えてハードウェアでプログラムを実行した際にかかる時間をある程度の精度で予測することも必須要件に加えられました．これにより，今までは仕事がなくなっていた学期末に仕事が入ります． 発展課題として512×512の画像サイズのレイトレが追加 必須要件は128×128の画像のレンダリングの速度競争ですが，発展としてその4(16)倍の大きさの画像のレンダリングの速度競争が行われます． 書き洩らしがあればご一報願います． プログラムで自由に回路を変更できるデバイス ↩︎ DiscordやSlackもありますがやっぱり対面のほうが話しやすいです ↩︎ 完全オンラインになっても全員が手元で動作させられるようにするため ↩︎","link":"/2022/01/08/CPUExpChange/"},{"title":"CPU実験の振り返り(シミュレータ係，前編)","text":"私の所属する学科の名物実験であるCPU実験も大詰めに近づいてきたので，このあたりで途中経過を振り返ってみたいと思います． CPU実験についての説明は先輩方が丁寧に説明したくださっている記事があるのでそちらをご覧ください．「CPU実験」と検索すると沢山ヒットします． また，私の代でこの授業に大幅な変更がありました．詳しくはこちらをご覧ください． 9月後半 軽い予習 10月前半 顔合わせ，初期ISA決定，Fibシミュレータ作成など 10月後半 GUIの作成, FPU, メモリの組み込み 11月 機能拡張，高速化，1stシミュレータの完成? 9月後半 軽い予習 このあたりでどの係にするかの希望を出します．先輩のブログや説明資料から考えて，私はシミュレータ係を希望し，そのまま通りました．コンパイラ係の希望が少し多かったので，一部の人がコア，FPU係に移動していました． 係も決まり，特にすることもなかったので軽く予習をしておくことにしました．CPU実験のシミュレータは他の係がデバッグに用いるため，なるべく高速に動作することが求められます．そのため，CやC++のような高速な言語で開発するほうが好ましいです．また，班員がコードを確認したり，改造を加えたりすることもあるので，班員も扱える言語のほうがよいです．Cは必修だったので全員使えますが，あまりにもライブラリが乏しいため，C++を使うことにしました．私はJavaをよく使っていたのでこれの履修には特に苦労しませんでした． 10月前半 顔合わせ，初期ISA決定，Fibシミュレータ作成など 10月になって班の割り振りが決定され，ここから進捗発表会が始まります． 最初の1週間でISAとしてRISC-Vのサブセットを使うことを決定しました．大体の班が同様な決定をしていましたが，配布されるコンパイラがデフォルトでPowerPCのアセンブリを出力できることからそれをISAとして使った班もありました． ここからまずはフィボナッチ数を計算できるコアの作成を目指します． シミュレータ係としてはいかに早くシミュレータを作成して班員が使えるようにするかが重要だと思ったので，ISAの決定の数日後にはアセンブリの書式の決定とそのインタプリタの作成を終えました．この後必要そうな機能を追加していきます．例えば， ブレークポイント機能 命令の巻き戻し機能 実行命令数などの統計情報表示 などが挙げられます．統計情報はデバッグにはあまり使いませんが，コンパイラやISAの改良を行う際に使われました． アセンブラについては，コア係が作ってくれたものを互いに機能拡張するという形で開発しました． 10月後半 GUIの作成, FPU, メモリの組み込み このあと，GUIの作成をした班があったので，対抗して(ほぼ自己満のために)GUIの作成にもとりかかりました．JavaでGUIを作ったことは何度かあったので，メインの処理は今まで作ったCLIのソフトにさせ，それとプロセス間通信をさせる形でJavaのGUIを作成しました．一応コア係には好評だったのでよかったですが，他の機能拡張を優先すべきだったかもしれません． また，このころFPUのVerilogでの実装が少しずつ上がっていたので，それをC++に落とし込む作業をしました．本来のハードウェア開発ではシミュレータが作成→それとまったく同じ挙動をするようにハードウェアを開発の順番なのですが，仕事の分担の関係上，FPUに関しては逆転してしまうのは仕方ない気がします．久しぶりのVerilogのコードに戸惑い，検証のコードにバグを仕込むというやらかしを行い，FPU係に迷惑をかけてしまいました(すみません)． でも，これだけは言わせてください．C++のシフトの仕様は罠です[1]． あとメモリの組み込みもこの頃行いました． 班の進捗としてはこの頃フィボナッチ数を計算できるコアはできていた気がします． 11月 機能拡張，高速化，1stシミュレータの完成? 以降，FPUが作ってくれたコードをC++に落とし込みながら機能拡張を続けました．この頃行ったものの例としては， エントリポイントへの対応 ディスアセンブラの作成 ワードデータを以下の表記で相互変換できるツールの作成 符号有無と2・10・16進法の変換 メモリの実装と同じエンディアンでエンコードしたときの4バイト 高速化 gprofでどこが時間かかっているかを調べられる アセンブラを作ると同時にディスアセンブラを作っておけばアセンブラのデバッグをかなり効率化できたので，これについてはもっと早く作っておくべきだったなと思っています． 以上とMMIOによる通信とキャッシュのシミュレータを追加して，1stコアのシミュレータを終えました．例年であればここで単位を確定できるのですが，今年からは速度予測が必須になるので，コアが完成させて速度予測に必要となるパラメータを収集できるまで単位はお預けです． 班の進捗としては，月の終わりにコンパイラ係がレイトレのプログラムをコンパイルでき，シミュレータ上で画像生成をすることができました(この際にシミュのバグをコンパイラ係に指摘してもらいました…申し訳ない)． 執筆現在1月なので，12月の振り返りも書けるのですが，バランスを考えて全部終わったときに以降は書きたいと思います． 論理シフト，算術シフトの区別がない．ビット幅以上のシフトが未定義． ↩︎","link":"/2022/01/09/CPUExp1/"}],"tags":[{"name":"大学","slug":"大学","link":"/tags/%E5%A4%A7%E5%AD%A6/"},{"name":"CPU実験","slug":"CPU実験","link":"/tags/CPU%E5%AE%9F%E9%A8%93/"},{"name":"GAN","slug":"GAN","link":"/tags/GAN/"},{"name":"深層学習","slug":"深層学習","link":"/tags/%E6%B7%B1%E5%B1%A4%E5%AD%A6%E7%BF%92/"},{"name":"遊び","slug":"遊び","link":"/tags/%E9%81%8A%E3%81%B3/"},{"name":"BrainF*ck","slug":"BrainF-ck","link":"/tags/BrainF-ck/"}],"categories":[{"name":"大学","slug":"大学","link":"/categories/%E5%A4%A7%E5%AD%A6/"},{"name":"開発","slug":"開発","link":"/categories/%E9%96%8B%E7%99%BA/"},{"name":"遊び","slug":"遊び","link":"/categories/%E9%81%8A%E3%81%B3/"}]}